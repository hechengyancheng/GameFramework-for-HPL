# 声明式冒险游戏示例 - 简化版
# 使用固定输入值，无需交互式输入
# 展示如何利用YAML的声明式特性简化HPL代码

imports:
  - ../core/game_engine: engine
  - ../core/scene: scene
  - ../core/player: player
  - ../utils/interaction: ui

# 使用include链接各个模块
includes:
  - modules/config.hpl
  - modules/player_config.hpl
  - modules/items.hpl
  - modules/scenes.hpl

# 固定输入值配置
fixed_inputs:
  player_name: "Hero"
  class_choice: "1"  # 1=战士, 2=法师, 3=游侠

main: () => {
    # 显示欢迎信息
    ui.show_narration(config.title)
    ui.show_narration(config.description)
    
    # 使用固定值获取玩家名称
    player_name = fixed_inputs.player_name
    ui.show_system("玩家名称: " + player_name)
    
    # 使用固定值选择职业
    class_choice = fixed_inputs.class_choice
    ui.show_narration("=== 职业选择 ===")
    
    # 根据职业选择初始化配置
    selected_class = "default"
    if (class_choice == "1") :
      selected_class = "warrior"
      ui.show_system("你选择了战士职业！")
      ui.show_system(player_config.warrior.description)
    elif (class_choice == "2") :
      selected_class = "mage"
      ui.show_system("你选择了法师职业！")
      ui.show_system(player_config.mage.description)
    elif (class_choice == "3") :
      selected_class = "ranger"
      ui.show_system("你选择了游侠职业！")
      ui.show_system(player_config.ranger.description)
    else :
      ui.show_system("输入无效，使用默认配置。")
    
    # 创建游戏引擎
    engine_id = engine.create_game_engine()
    
    # 初始化游戏
    engine.initialize_game(engine_id, player_name, player)
    
    # 注册所有场景
    for (scene_data in scenes) :


      s = scene.create_scene(scene_data.id, scene_data.name, scene_data.description)
      
      # 添加选择项
      if (scene_data.choices != null) :
        for (choice_data in scene_data.choices) :
          # 处理动作代码 - 直接传递字符串，由 scene.py 执行
          action_value = null
          try :
            action_value = choice_data["action"]
          catch (err) :
            action_value = null
          
          target = choice_data.target
          if (target == null) :
            target = null
          
          c = scene.create_choice(choice_data.text, target, null, action_value)

          scene.add_choice(s, c)
      
      # 注册 on_enter 回调
      on_enter_value = null
      try :
        on_enter_value = scene_data["on_enter"]
      catch (err) :
        on_enter_value = null
      if (on_enter_value != null) :
        scene.set_scene_on_enter(scene_data.id, on_enter_value)
      
      # 注册 on_exit 回调
      on_exit_value = null
      try :
        on_exit_value = scene_data["on_exit"]
      catch (err) :
        on_exit_value = null
      if (on_exit_value != null) :
        scene.set_scene_on_exit(scene_data.id, on_exit_value)

      
      # 注册场景
      engine.register_scene(engine_id, s)

    
    # 设置起始场景
    engine.set_start_scene(engine_id, config.start_scene)
    
    # 获取玩家对象并添加初始物品
    p = engine.get_player(engine_id)
    
    # 根据职业添加初始物品和属性
    class_config = null
    if (selected_class == "warrior") :
      class_config = player_config.warrior
    elif (selected_class == "mage") :
      class_config = player_config.mage
    elif (selected_class == "ranger") :
      class_config = player_config.ranger
    else :
      class_config = player_config
    
    # 设置职业特定属性
    if (class_config.initial_stats != null) :
      player.set_player_stat(p, "hp", class_config.initial_stats.hp)
      player.set_player_stat(p, "max_hp", class_config.initial_stats.max_hp)
      player.set_player_stat(p, "mp", class_config.initial_stats.mp)
      player.set_player_stat(p, "max_mp", class_config.initial_stats.max_mp)
      player.set_player_stat(p, "gold", class_config.initial_stats.gold)
      player.set_player_stat(p, "attack", class_config.initial_stats.attack)
      player.set_player_stat(p, "defense", class_config.initial_stats.defense)
      player.set_player_stat(p, "magic", class_config.initial_stats.magic)
    
    # 添加职业特定初始物品
    if (class_config.initial_items != null) :
      for (item_data in class_config.initial_items) :
        item = player.create_item(item_data.id, item_data.name, item_data.description, item_data.type, item_data.value)
        player.add_item_to_inventory(p, item)

    
    # 显示初始状态
    ui.pause("按回车键开始游戏...")
    player.show_player_status(p)
    
    # 运行游戏
    engine.run_game(engine_id)
  }


call: main()
